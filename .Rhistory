}
IdentifyRunTypes <- function(msdial.file) {
# Identify run typfes and return each unique value present in the Skyline output.
#
# Args
#   msdial.file: Raw output file from Skyline.
#
# Returns
#   run.type: list of labels identifying the run types, isolated from Replicate.Name.
#   Options conssist of samples (smp), pooled (poo), standards (std), and blanks (blk).
#
run.type <- tolower(str_extract(msdial.file$ReplicateName, "(?<=_)[^_]+(?=_)"))
print(paste("Your runtypes are:", toString(unique(run.type))))
}
area.min   <- 1000
RT.flex    <- 0.4
blk.thresh <- 0.3
SN.min     <- 4
msdial.runtypes <- IdentifyRunTypes(combined)
combined <- combined %>%
select(ReplicateName:Alignment.ID, Metabolite.name) %>%
mutate(Run.Type = (tolower(str_extract(combined$ReplicateName, "(?<=_)[^_]+(?=_)"))))
RT.table <- combined %>%
filter(Run.Type == "std") %>%
arrange(Metabolite.name) %>%
group_by(Metabolite.name) %>%
mutate(RT.min = min(RTValue, na.rm = TRUE)) %>%
mutate(RT.max = max(RTValue, na.rm = TRUE)) %>%
select(Metabolite.name:RT.max) %>%
unique()
blank.table <- combined %>%
filter(Run.Type == "blk") %>%
mutate(Blk.Area = AreaValue) %>%
arrange(Metabolite.name) %>%
group_by(Metabolite.name) %>%
mutate(Blk.min = min(AreaValue)) %>%
mutate(Blk.max = max(AreaValue)) %>%
select(Metabolite.name:Blk.max) %>%
select(-Blk.Area) %>%
unique()
# Create datasets for different flag types.
SN.Area.Flags <- combined %>%
arrange(Metabolite.name) %>%
mutate(SN.Flag       = ifelse(((SNValue) < SN.min), "SN.Flag", NA)) %>%
mutate(area.min.Flag = ifelse((AreaValue < area.min), "area.min.Flag", NA))
# Joining datasets---------------------------------------
add.RT.Flag <- SN.Area.Flags %>%
group_by(Metabolite.name) %>%
left_join(RT.table, by = c("Metabolite.name", "Run.Type")) %>%
mutate(RT.Flag = ifelse((RTValue >= (RT.max + RT.flex) | RTValue <= (RT.min - RT.flex)), "RT.Flag", NA)) %>%
select(-c("RT.max", "RT.min"))
add.blk.Flag <- add.RT.Flag %>%
left_join(blank.table, by = c("Metabolite.name", "Run.Type")) %>%
mutate(blank.Flag = ifelse((AreaValue / Blk.max) < blk.thresh, "blank.Flag", NA)) %>%
select(-c("Blk.min", "Blk.max"))
# Finally, combine all the flags.
final.table <- add.blk.Flag %>%
mutate(all.Flags      = paste(SN.Flag, area.min.Flag, RT.Flag, blank.Flag, sep = ", ")) %>%
mutate(all.Flags      = as.character(all.Flags %>% str_remove_all("NA, ") %>% str_remove_all("NA"))) %>%
mutate(Area.with.QC   = ifelse(is.na(area.min.Flag), AreaValue, NA)) %>%
select(ReplicateName:AreaValue, Area.with.QC, everything()) %>%
ungroup(Metabolite.name) %>%
mutate(Metabolite.name = as.character(Metabolite.name)) %>%
mutate(Metabolite.name = ifelse(str_detect(Metabolite.name, "Ingalls_"), sapply(strsplit(Metabolite.name, "_"), `[`, 2), Metabolite.name))
# Print to file with comments and new name!
Description <- c("Hello! Welcome to the world of MSDIAL QE Quality Control! ",
"Minimum area for a real peak: ",
"RT flexibility: ",
"Blank can be this fraction of a sample: ",
"S/N ratio: " ,
"Processed on: ")
Value <- c(NA, area.min, RT.flex, blk.thresh, SN.min, Sys.time())
df <- data.frame(Description, Value)
final.table <- bind_rows(df, final.table)
rm(list=setdiff(ls(), "final.table"))
write.csv(final.table, "./data_processed/QC_Output.csv", row.names = FALSE)
library(ggplot2)
library(stringr)
library(tidyverse)
options(scipen=999)
## This BMIS is for Wei's Eddy Transect data.
# Things to Return --------------------------------------------------------
# IS_inspectPlot (plot to make sure there aren't any internal standards we should kick out)
# QuickReport (% that picked BMIS, with cut off values)
# ISTest_plot (plot to evaluate if you cut off is appropriate)
# BMIS_normalizedData (tibble with the info you actually want!)
# Imports -----------------------------------------------------------------
Wei.transect.SampKey_all <- read.csv("data_extras/Sample.Key.EddyTransect.csv") %>%
mutate(Sample.Name = Sample.Name %>%
str_replace("-","."))
Wei.transect.SampKey_all[Wei.transect.SampKey_all == "180821_Poo_MesoScopeQC_1a"] <- "180821_Poo_MesoScopeQC_1"
Wei.Internal.Standards <- read.csv("data_extras/Ingalls_Lab_Standards.csv") %>%
filter(Column == "HILIC") %>%
filter(Compound.Type == "Internal Standard")
trimws(Wei.Internal.Standards$Compound.Name, which = c("both", "left", "right"), whitespace = "[ \t\r\n]")
# HILICPos and HILICNeg data
Wei.transect <- read.csv("data_processed/QC_Output.csv", header = TRUE) %>%
slice(-1:-6) %>%
select(-c(Description, Value))
# Change class + adjust data. Set cutoff values -----------------------------------------------------------------
Wei.transect <- Wei.transect %>%
filter(!str_detect(ReplicateName, "Blk")) %>%
filter(!str_detect(ReplicateName, "Std")) %>%
mutate(ReplicateName = as.character(ReplicateName)) %>%
mutate(Metabolite.name = as.character(Metabolite.name)) %>%
mutate(RTValue = as.numeric(RTValue)) %>%
mutate(AreaValue = as.numeric(AreaValue)) %>%
mutate(SNValue = as.numeric(SNValue)) %>%
filter(!(Column == "HILICNeg" & Metabolite.name == "Inosine")) %>%
filter(!(Column == "HILICNeg" & Metabolite.name == "Guanine")) %>%
mutate(Metabolite.name = ifelse(str_detect(Metabolite.name, "Ingalls_"), sapply(strsplit(Metabolite.name, "_"), `[`, 2), Metabolite.name))
cut.off <- 0.3 # 30% decrease in RSD of pooled injections, aka improvement cutoff
cut.off2 <- 0.1 # RSD minimum
# Match transect data with Internal Standards list -----------------------------------------------------------------
Wei.transect.withIS <- Wei.transect %>%
filter(Metabolite.name %in% Wei.Internal.Standards$Compound.Name)
Wei.transect.NoIS <- Wei.transect %>%
filter(!Metabolite.name %in% Wei.Internal.Standards$Compound.Name)
# Read in Internal Standard data -----------------------------------------------------------------
# If injection volume is known, add in here.
Wei.transect.IS.data <- Wei.transect.withIS %>%
select(ReplicateName, Metabolite.name, Area.with.QC) %>%
mutate(MassFeature = Metabolite.name) %>%
select(-Metabolite.name) %>%
filter(!MassFeature == "Guanosine Monophosphate, 15N5")
# Drop syntactically correct "X" at start of ReplicateName.
Wei.transect.IS.data$ReplicateName <- gsub("^.{0,1}", "", Wei.transect.IS.data$ReplicateName)
Wei.transect.SampKey <- Wei.transect.SampKey_all %>%
filter(Sample.Name %in% Wei.transect.IS.data$ReplicateName) %>% # Drops standards from SampKey_all
select(Sample.Name, Bio.Normalization) %>%
mutate(MassFeature = "Inj_vol",
Area.with.QC = Bio.Normalization,
ReplicateName = Sample.Name) %>%
select(ReplicateName, Area.with.QC, MassFeature)
Wei.transect.IS.data <- rbind(Wei.transect.IS.data, Wei.transect.SampKey)
# THIS REMOVAL OF DDA SAMPLES IS ADDED AS A STOPGAP MEASURE- NEEDS TO BE FIXED!!! ##
Wei.transect.IS.data <- Wei.transect.IS.data %>%
filter(!grepl("DDA", ReplicateName))
# THIS REMOVAL OF DDA SAMPLES IS ADDED AS A STOPGAP MEASURE- NEEDS TO BE FIXED!!! ##
# Identify internal standards without an Area, i.e. any NA values.
IS_Issues <- Wei.transect.IS.data[is.na(Wei.transect.IS.data$Area.with.QC),]
# Extraction replication of Internal Standards -----------------------------------------------------------------
IS_inspectPlot <- ggplot(Wei.transect.IS.data, aes(x = ReplicateName, y = Area.with.QC)) +
geom_bar(stat = "identity") +
facet_wrap( ~MassFeature, scales = "free_y") +
theme(axis.text.x = element_text(angle = 90, hjust = 1,vjust = 0.5, size = 5),
axis.text.y = element_text(size = 10),
legend.position = "top",
strip.text = element_text(size = 10))+
ggtitle("IS Raw Areas")
# print(IS_inspectPlot)
# Edit data so names match-----------------------------------------------------------------
Wei.transect.IS.data <- Wei.transect.IS.data %>%
mutate(ReplicateName = ReplicateName %>%
str_replace("-",".")) %>%
arrange(ReplicateName)
Wei.transect.long  <- Wei.transect.NoIS %>%
rename(MassFeature = Metabolite.name) %>%
select(ReplicateName, MassFeature, Area.with.QC) %>%
arrange(ReplicateName)
# Drop syntactically valid "X" from ReplicateName.
Wei.transect.long$ReplicateName <- gsub("^.{0,1}", "", Wei.transect.long$ReplicateName)
# Test that names are equal
test_IS.data <- as.data.frame(unique(Wei.transect.IS.data$ReplicateName))
test_IS.data <- test_IS.data %>%
mutate(ReplicateName = as.character(unique(Wei.transect.IS.data$ReplicateName)))
test_long.data <- as.data.frame(unique(Wei.transect.long$ReplicateName))
test_long.data <- test_long.data %>%
mutate(ReplicateName = as.character(unique(Wei.transect.long$ReplicateName))) %>%
filter(!grepl("DDA", ReplicateName))
# This is being manually forced to identical() == TRUE because of DDA removal.
identical(test_IS.data$ReplicateName, test_long.data$ReplicateName)
# Caluclate mean values for each IS----------------------------------------------------------------
Wei.transect.IS.means <- Wei.transect.IS.data %>%
filter(!grepl("_Blk_", ReplicateName)) %>%
mutate(MassFeature = as.factor(MassFeature)) %>%
group_by(MassFeature) %>%
summarise(Average.Area = mean(as.numeric(Area.with.QC), na.rm = TRUE)) %>%
mutate(MassFeature = as.character(MassFeature))
Wei.transect.IS.means[is.na(Wei.transect.IS.means)] <- NA
# Normalize to each internal Standard----------------------------------------------------------------
Wei.transect.binded <- rbind(Wei.transect.IS.data, Wei.transect.long) %>%
arrange(MassFeature)
Split_Dat <- list()
for (i in 1:length(unique(Wei.transect.IS.data$MassFeature))) {
Split_Dat[[i]] <- Wei.transect.binded %>%
mutate(MIS = unique(Wei.transect.IS.data$MassFeature)[i]) %>%
left_join(Wei.transect.IS.data %>%
rename(MIS = MassFeature, IS_Area = Area.with.QC) %>%
select(MIS, ReplicateName, IS_Area), by = c("ReplicateName", "MIS")) %>%
left_join(Wei.transect.IS.means %>%
rename(MIS = MassFeature), by = "MIS") %>%
mutate(Adjusted_Area = Area.with.QC/IS_Area*Average.Area)
}
Wei.transect.area.norm <- do.call(rbind, Split_Dat) %>%
select(-IS_Area, -Average.Area)
# Standardize name structure to: Date_type_ID_replicate_anythingextraOK) ----------------------------------------------------------------
Wei.transect.mydata_new <- Wei.transect.area.norm %>%
separate(ReplicateName, c("runDate", "type", "SampID", "replicate"), "_") %>%
mutate(Run.Cmpd = paste(Wei.transect.area.norm$ReplicateName, Wei.transect.area.norm$MassFeature))
# Find the B-MIS for each MassFeature----------------------------------------------------------------
# Look only at the Pooled samples, to get a lowest RSD of the pooled possible (RSD_ofPoo),
# then choose which IS reduces the RSD the most (Poo.Picked.IS)
Wei.transect.poodat <- Wei.transect.mydata_new %>%
filter(type == "Poo") %>%
group_by(SampID, MassFeature, MIS) %>%
summarise(RSD_ofPoo_IND = sd(Adjusted_Area, na.rm = TRUE) / mean(Adjusted_Area, na.rm = TRUE)) %>%
mutate(RSD_ofPoo_IND = ifelse(RSD_ofPoo_IND == "NaN", NA, RSD_ofPoo_IND)) %>%
group_by(MassFeature, MIS) %>%
summarise(RSD_ofPoo =  mean(RSD_ofPoo_IND, na.rm = TRUE)) %>%
mutate(RSD_ofPoo = ifelse(RSD_ofPoo == "NaN", NA, RSD_ofPoo)) # New addition to transform NaNs to NAs
Wei.transect.poodat <- Wei.transect.poodat %>%
left_join(Wei.transect.poodat %>% group_by(MassFeature) %>%
summarise(Poo.Picked.IS = unique(MIS)[which.min(RSD_ofPoo)] [1]))
# Get the original RSD, calculate RSD change, decide if MIS is acceptable----------------------------------------------------------------
Wei.transect.poodat <- left_join(Wei.transect.poodat, Wei.transect.poodat %>%
filter(MIS == "Inj_vol" ) %>%
mutate(Orig_RSD = RSD_ofPoo) %>%
select(-RSD_ofPoo, -MIS)) %>%
mutate(del_RSD = (Orig_RSD - RSD_ofPoo)) %>%
mutate(percentChange = del_RSD/Orig_RSD) %>%
mutate(accept_MIS = (percentChange > cut.off & Orig_RSD > cut.off2))
# Change the BMIS to "Inj_vol" if the BMIS is not an acceptable----------------------------------------------------------------
# Adds a column that has the BMIS, not just Poo.picked.IS
# Changes the FinalBMIS to inject_volume if its no good
Wei.transect.fixedpoodat <- Wei.transect.poodat %>%
filter(MIS == Poo.Picked.IS) %>%
mutate(FinalBMIS = ifelse(accept_MIS == "FALSE", "Inj_vol", Poo.Picked.IS)) %>%
mutate(FinalRSD = RSD_ofPoo)
Wei.newpoodat <- Wei.transect.poodat %>%
left_join(Wei.transect.fixedpoodat %>% select(MassFeature, FinalBMIS)) %>%
filter(MIS == FinalBMIS) %>%
mutate(FinalRSD = RSD_ofPoo)
Try <- Wei.newpoodat %>%
filter(FinalBMIS != "Inj_vol")
QuickReport <- print(paste("% of MFs that picked a BMIS",
length(Try$MassFeature) / length(Wei.newpoodat$MassFeature),
"RSD improvement cutoff", cut.off,
"RSD minimum cutoff", cut.off2,
sep = " "))
# Evaluate the results of your BMIS cutoff----------------------------------------------------------------
IS_toISdat <- Wei.transect.mydata_new %>%
filter(MassFeature %in% Wei.transect.IS.data$MassFeature) %>%
select(MassFeature, MIS, Adjusted_Area, type) %>%
filter(type == "Smp") %>%
group_by(MassFeature, MIS) %>%
summarise(RSD_ofSmp = sd(Adjusted_Area, na.rm = TRUE)/mean(Adjusted_Area, na.rm = TRUE)) %>%
left_join(Wei.transect.poodat %>% select(MassFeature, MIS, RSD_ofPoo, accept_MIS))
injectONlY_toPlot <- IS_toISdat %>%
filter(MIS == "Inj_vol")
ISTest_plot <- ggplot() +
geom_point(dat = IS_toISdat, shape = 21, color = "black", size = 2,aes(x = RSD_ofPoo, y = RSD_ofSmp, fill = accept_MIS)) +
scale_fill_manual(values=c("white","dark gray")) +
geom_point(dat = injectONlY_toPlot, aes(x = RSD_ofPoo, y = RSD_ofSmp), size = 3) +
facet_wrap(~ MassFeature)
#print(ISTest_plot)
# Return data that is normalized via BMIS----------------------------------------------------------------
## original
Wei.transect.BMIS_normalizedData <- Wei.newpoodat %>% select(MassFeature, FinalBMIS, Orig_RSD, FinalRSD) %>%
left_join(Wei.transect.mydata_new, by = "MassFeature") %>%
filter(MIS == FinalBMIS) %>%
#########
#filter(str_detect("DDA", Run.Cmpd)) %>%
##########
unique()
View(Wei.transect.BMIS_normalizedData)
write.csv(Wei.transect.BMIS_normalizedData, file = "data_processed/BMIS_Output.csv")
rm(list=setdiff(ls()))
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE) # Set up of code and library, include = False prevents this chunk from showing up, but this line changes the default global options, and the echo = True should set the below chunks to show up.
library(tidyverse)
library(parallel)
options(scipen=999)
Wei.Ingalls.Standards <- read.csv("data_extras/Ingalls_Lab_Standards.csv") %>%
filter(Column == "HILIC") %>%
select(Compound.Name, z, QE.RF.ratio, HILICMix, Conc..uM, Emperical.Formula) %>%
filter(!is.na(Conc..uM))
## duplicate rows testing for hilicpos and hilicneg IDs. this can be a sourced function.
test <- which(duplicated(Wei.Ingalls.Standards$Compound.Name))
duplicate_compounds <- as.data.frame(Wei.Ingalls.Standards$Compound.Name[test]) %>%
rename(Compound.Name = 1)
## New version that simply drops the compounds that are visible in both postive and negative HILIC runs.
# Wei.Ingalls.Standards <- Wei.Ingalls.Standards %>%
#   filter(!Compound.Name %in% duplicate_compounds$`Wei.Ingalls.Standards$Compound.Name[test]`)
# Import full file and clean initial data.
Wei.HILICS.transect <- read.csv("data_processed/QC_Output.csv", header = TRUE) %>%
slice(-1:-6) %>%
select(-c(Description, Value)) %>%
mutate(ReplicateName = as.character(ReplicateName)) %>%
select(ReplicateName, Metabolite.name, Column, Area.with.QC, AreaValue, Run.Type)
Wei.HILICS.transect$ReplicateName <- gsub("^.{0,1}", "", Wei.HILICS.transect$ReplicateName)
Wei.HILICS.raw.transect <- Wei.HILICS.transect %>%
filter(Metabolite.name %in% Wei.Ingalls.Standards$Compound.Name) %>%
rename(Compound.Name = Metabolite.name)
# Apply appropriate filters and isolate standards.
Wei.HILICS.transect <- Wei.HILICS.transect %>%
filter(Metabolite.name %in% Wei.Ingalls.Standards$Compound.Name) %>%
filter(str_detect(ReplicateName, "Std")) %>%
mutate(AreaValue = as.numeric(as.character(AreaValue))) %>%
mutate(Area.with.QC = as.numeric(as.character(Area.with.QC))) %>%
mutate(Compound.Name = Metabolite.name) %>%
select(-Metabolite.name) %>%
left_join(Wei.Ingalls.Standards, by = "Compound.Name") %>%
select(ReplicateName, Compound.Name, everything())
Wei.HILICS.transect <- Wei.HILICS.transect %>%
group_by(Compound.Name) %>%
mutate(pos.and.neg = ifelse(Compound.Name %in% duplicate_compounds$Compound.Name, TRUE, FALSE)) %>%
filter(!(pos.and.neg == TRUE & z == -1)) %>%
filter(!(Compound.Name == "Inosine" & Column == "HILICNeg")) %>%
filter(!(Compound.Name == "Guanine" & Column == "HILICNeg")) %>%
mutate(z = ifelse(Column == "HILICNeg", -1, 1)) %>%
select(-pos.and.neg)
Wei.RFs.transect <- Wei.HILICS.transect %>%
mutate(RF = as.numeric(as.character(Area.with.QC))/as.numeric(Conc..uM))
Wei.RFs2.transect <- Wei.RFs.transect %>%
mutate(Type = paste(Env = ifelse(str_detect(ReplicateName, "StdsMix|InH2O"), "Standards", "Water"),
Matrix = ifelse(str_detect(ReplicateName, "InMatrix"), "Matrix", "Water"), sep = "_")) %>%
filter(str_detect(ReplicateName, as.character(HILICMix)) | str_detect(ReplicateName, "H2OInMatrix")) %>%
filter(!str_detect(Compound.Name, ",")) %>%
mutate(ReplicateName = substr(ReplicateName, 1, nchar(ReplicateName)-2))
# Calculate RF max and min using only standards in water.
Wei.transect.RFs.dimensions <- Wei.RFs2.transect %>%
filter(Type == "Standards_Water") %>%
group_by(Compound.Name) %>%
mutate(RF.max = max(RF, na.rm = TRUE),
RF.min = min(RF, na.rm = TRUE))
Wei.transect.RFs.dimensions$RF.max[is.infinite(Wei.transect.RFs.dimensions$RF.max) | is.nan(Wei.transect.RFs.dimensions$RF.max) ] <- NA
Wei.transect.RFs.dimensions$RF.min[is.infinite(Wei.transect.RFs.dimensions$RF.min) | is.nan(Wei.transect.RFs.dimensions$RF.min) ] <- NA
Wei.transect.RFs.dimensions <- Wei.transect.RFs.dimensions %>%
mutate(RF.diff = RF.max/RF.min) %>%
unique()
# Calculate the response factor ratios using (Standards in Matrix - Water in Matrix) / Standards in water for each replicate.
Wei.transect.RFratios <- Wei.RFs2.transect %>%
group_by(Compound.Name, Type) %>%
mutate(RF.mean.per_sampleID = mean(RF, na.rm = TRUE)) %>%
select(ReplicateName, Compound.Name, Type, RF.mean.per_sampleID) %>%
unique() %>%
group_by(Compound.Name) %>% filter(n() >= 3) %>%
mutate(RF.ratio = ((RF.mean.per_sampleID[Type == "Standards_Matrix"] - RF.mean.per_sampleID[Type == "Water_Matrix"]) / RF.mean.per_sampleID[Type == "Standards_Water"])) %>%
select(Compound.Name, RF.ratio) %>%
unique()
Wei.transect.RFratios$RF.ratio[Wei.transect.RFratios$Compound.Name == "Choline"] <- 1
Wei.transect.RFratios$RF.ratio[Wei.transect.RFratios$Compound.Name == "Trimethyl-L-lysine"] <- NA ## DROPPED DUE TO SUPER WEIRD NUMBERS
Wei.transect.RFratios$RF.ratio[is.nan(Wei.transect.RFratios$RF.ratio)] <- NA
rm(list = c("Wei.RFs.transect", "Wei.RFs2.transect"))
test.RFratios <- Wei.transect.RFratios %>%
filter(is.na(RF.ratio))
test.standards <- Wei.Ingalls.Standards %>%
filter(Compound.Name %in% test.RFratios$Compound.Name) %>%
rename(RF.ratio = QE.RF.ratio) %>%
select(Compound.Name, RF.ratio) %>%
mutate(Compound.Name = as.character(Compound.Name)) %>%
mutate(RF.ratio = as.character(RF.ratio))
Wei.transect.RFratios <- Wei.transect.RFratios %>%
as.data.frame() %>%
filter(!is.na(RF.ratio)) %>%
rbind(test.standards)
Wei.Samp.Data.transect <- read.csv("data_processed/BMIS_Output.csv") %>%
separate(Run.Cmpd, sep = " ", into = c("Sample.Name")) %>%
mutate(Compound.Name = MassFeature) %>%
filter(Compound.Name %in% Wei.transect.RFratios$Compound.Name) %>%
left_join(Wei.transect.RFratios) %>%
left_join(Wei.transect.RFs.dimensions %>% select(Compound.Name, Column, RF.max, RF.min) %>% unique(), by = "Compound.Name") %>%
mutate(RF.ratio = as.numeric(RF.ratio)) %>%
select(Compound.Name, FinalBMIS, Sample.Name, Adjusted_Area, everything())
Wei.Quan.Dat.transect <- Wei.Samp.Data.transect %>%
mutate(RF.ave = as.numeric(rowMeans(Wei.Samp.Data.transect[, c("RF.min", "RF.max")]))) %>%
mutate(umol.in.vial.ave = Adjusted_Area/RF.ave/RF.ratio,
umol.in.vial.max = Adjusted_Area/RF.min/RF.ratio,
umol.in.vial.min = Adjusted_Area/RF.max/RF.ratio) %>%
select(Compound.Name:Adjusted_Area, everything())
original.IS.key <- read.csv("data_extras/InternalStandardNames.csv") %>%
rename(FinalBMIS = Internal_Standards) %>%
mutate(FinalBMIS = as.character(FinalBMIS))
original.IS.key <- read.csv("data_extras/InternalStandardNames.csv") %>%
rename(FinalBMIS = Internal_Standards) %>%
mutate(FinalBMIS = as.character(FinalBMIS))
Wei.IS.key <- Wei.Samp.Data.transect %>%
select(FinalBMIS, MassFeature) %>%
rename(Compound.Name = MassFeature) %>%
unique() %>%
#mutate(FinalBMIS = str_remove(FinalBMIS, ".Norm.Area")) %>%
left_join(original.IS.key %>% select(FinalBMIS, Concentration_nM)) %>%
filter(str_detect(FinalBMIS, as.character(Compound.Name)))
rm(original.IS.key)
Wei.IS.data.transect <- Wei.HILICS.transect %>%
filter(as.character(Compound.Name) %in% Wei.IS.key$FinalBMIS) %>%
mutate(IS_Area = Area.with.QC,
FinalBMIS = Compound.Name) %>%
select(IS_Area, FinalBMIS, ReplicateName) %>%
left_join(Wei.IS.key %>% select(FinalBMIS, Concentration_nM))
IS.names <- data.frame(Compounds = c(Wei.IS.key[ ,"FinalBMIS"], as.character(Wei.IS.key[ ,"Compound.Name"])))
Wei.IS.smp.data.transect <- Wei.HILICS.raw.transect %>%
left_join(Wei.IS.data.transect %>% select(Compound.Name, Concentration_nM)) %>%
unique() %>%
filter(Compound.Name %in% IS.names$Compounds) %>%
filter(!str_detect(ReplicateName, "Std")) %>%
mutate(Std.Type = ifelse(str_detect(Compound.Name, ","), "Internal_std", "Standard")) %>%
mutate(testcol1 = ifelse(str_detect(Compound.Name, ","), sapply(strsplit(Compound.Name, ","), `[`, 1), Compound.Name)) %>%
mutate(Names = ifelse(str_detect(testcol1, "-"), sapply(strsplit(testcol1, "-"), `[`, 2), testcol1)) %>%
mutate(Pairs = ifelse(!str_detect(Compound.Name, ","), Compound.Name, paste(Names, "IS", sep = "_"))) %>%
select(-c("Pairs", "testcol1", "Run.Type")) %>%
mutate(Area.with.QC = as.numeric(as.character(Area.with.QC))) %>%
arrange(ReplicateName) %>%
group_by(Names) %>%
group_split()
Wei.IS.mid_frame <- lapply(Wei.IS.smp.data.transect, function(x) group_by(x, ReplicateName))
Wei.IS.mid_frame2 <- lapply(Wei.IS.mid_frame,
function(x)
mutate(x,
umol.in.vial_IS = (Area.with.QC[Std.Type == "Standard"] / Area.with.QC[Std.Type == "Internal_std"]) * (Concentration_nM[Std.Type == "Internal_std"]/1000)))
Wei.IS.smp.data.transect <- do.call(rbind, Wei.IS.mid_frame2) %>%
filter(!str_detect(Compound.Name, ",")) %>%
rename(Sample.Name = ReplicateName) %>%
select(Sample.Name:Area.with.QC, Concentration_nM, umol.in.vial_IS)
rm(list = c("IS.names", "Wei.HILICS.raw.eddycenter", "Wei.IS.mid_frame", "Wei.IS.mid_frame2"))
Wei.all.info <- Wei.Quan.Dat.transect %>%
left_join(Wei.IS.smp.data.transect %>% select(Sample.Name, Compound.Name, umol.in.vial_IS)) %>%
mutate(umol.in.vial.ave = ifelse(is.na(umol.in.vial_IS), umol.in.vial.ave, umol.in.vial_IS),
umol.in.vial.max = ifelse(is.na(umol.in.vial_IS), umol.in.vial.max, NA),
umol.in.vial.min = ifelse(is.na(umol.in.vial_IS), umol.in.vial.min, NA)) %>%
rename(ReplicateName = Sample.Name) %>%
filter(!str_detect(ReplicateName, "DDA"))
Dilution_Factor = 2
Wei.quanDat2 <- Wei.all.info %>%
mutate(nmol.in.Enviro.ave = (umol.in.vial.ave*10^-6*400/5*1000 * Dilution_Factor)) %>% # 5 liters is only for the transect
left_join(Wei.HILICS.transect %>% select(Compound.Name, Emperical.Formula)) %>%
select(Compound.Name, ReplicateName, Adjusted_Area, Orig_RSD:Emperical.Formula) %>%
unique()
# Okay dokay, go get how many Carbons and Nitrogens there are here.
Wei.quanDat3 <- Wei.quanDat2  %>%
mutate(C = ifelse(is.na(str_extract(Emperical.Formula, "^C\\d\\d")),
str_extract(Emperical.Formula, "^C\\d"),
str_extract(Emperical.Formula, "^C\\d\\d"))) %>%
mutate(C = as.numeric(str_replace_all(C, "C", ""))) %>%
mutate(N = ifelse(str_detect(Emperical.Formula, "N\\D"),
1,
str_extract(Emperical.Formula, "N\\d"))) %>%
mutate(N = as.numeric(str_replace_all(N, "N", ""))) %>%
mutate(nmol.C.ave = nmol.in.Enviro.ave*C,
nmol.N.ave = nmol.in.Enviro.ave*N ) %>%
#separate(Sample.Name, into = c("Date","type", "SampID", "replicate"), remove = FALSE) %>%
select(Compound.Name, SampID, ReplicateName, everything())
Wei.quanDatSum <- Wei.quanDat3 %>%
group_by(Compound.Name) %>%
summarise(nmol.Enviro.med = median(nmol.in.Enviro.ave, na.rm  = T),
nmol.Enviro.min = min(nmol.in.Enviro.ave, na.rm  = T),
nmol.Enviro.max = max(nmol.in.Enviro.ave, na.rm  = T),
nmol.C.med = median(nmol.C.ave, na.rm  = T),
nmol.C.min = min(nmol.C.ave, na.rm  = T),
nmol.C.max = max(nmol.C.ave, na.rm  = T)) %>%
arrange(desc(nmol.Enviro.med))
# Cacluate mole fractions of each compound.
Wei.TotalMoles <- Wei.quanDat3  %>%
select(SampID, nmol.C.ave, nmol.N.ave) %>%
group_by(SampID) %>%
summarise(totalCmeasured_nM_perID = sum(as.numeric(nmol.C.ave), na.rm = TRUE),
totalNmeasured_nM_perID = sum(as.numeric(nmol.N.ave), na.rm = TRUE))
#rename(SampID = type)
Wei.quanDat4 <- Wei.quanDat3 %>%
unique() %>%
left_join(Wei.TotalMoles) %>%
mutate(ratioCN = totalCmeasured_nM_perID / totalNmeasured_nM_perID) %>%
mutate(molFractionC = nmol.C.ave/totalCmeasured_nM_perID,
molFractionN = nmol.N.ave/totalNmeasured_nM_perID) %>%
select(Compound.Name, ReplicateName, Adjusted_Area, Area.with.QC, RF.ratio:molFractionN) %>%
unique()
Wei.quanDatSum <- Wei.quanDat4 %>%
group_by(Compound.Name) %>%
summarise(nmol.Enviro.med = median(nmol.in.Enviro.ave, na.rm  = T),
nmol.Enviro.min = min(nmol.in.Enviro.ave, na.rm  = T),
nmol.Enviro.max = max(nmol.in.Enviro.ave, na.rm  = T),
nmol.C.med = median(nmol.C.ave, na.rm  = T),
nmol.C.min = min(nmol.C.ave, na.rm  = T),
nmol.C.max = max(nmol.C.ave, na.rm  = T),
mol.C.Fraction.med = median(molFractionC, na.rm = T),
mol.C.Fraction.min = min(molFractionC, na.rm = T),
mol.C.Fraction.max = max(molFractionC, na.rm = T)) %>%
arrange(desc(Compound.Name))
# write.csv(Wei.quanDatSum, "~/Downloads/Complete_Wei_Transect_Summary_Nov19.csv")
# write.csv(Wei.quanDat4, "~/Downloads/Complete_Wei_Transect_Measurements_Nov19.csv")
# write.csv(Wei.TotalMoles, "~/Downloads/Complete_Wei_Transect_perSampID_Nov19.csv")
# Cacluate mole fractions of each compound.
Wei.TotalMoles <- Wei.quanDat3  %>%
select(SampID, nmol.C.ave, nmol.N.ave) %>%
group_by(SampID) %>%
summarise(totalCmeasured_nM_perID = sum(as.numeric(nmol.C.ave), na.rm = TRUE),
totalNmeasured_nM_perID = sum(as.numeric(nmol.N.ave), na.rm = TRUE))
#rename(SampID = type)
Wei.quanDat4 <- Wei.quanDat3 %>%
unique() %>%
left_join(Wei.TotalMoles) %>%
mutate(ratioCN = totalCmeasured_nM_perID / totalNmeasured_nM_perID) %>%
mutate(molFractionC = nmol.C.ave/totalCmeasured_nM_perID,
molFractionN = nmol.N.ave/totalNmeasured_nM_perID) %>%
select(Compound.Name, ReplicateName, Adjusted_Area, Area.with.QC, RF.ratio:molFractionN) %>%
unique()
Wei.quanDatSum <- Wei.quanDat4 %>%
group_by(Compound.Name) %>%
summarise(nmol.Enviro.med = median(nmol.in.Enviro.ave, na.rm  = T),
nmol.Enviro.min = min(nmol.in.Enviro.ave, na.rm  = T),
nmol.Enviro.max = max(nmol.in.Enviro.ave, na.rm  = T),
nmol.C.med = median(nmol.C.ave, na.rm  = T),
nmol.C.min = min(nmol.C.ave, na.rm  = T),
nmol.C.max = max(nmol.C.ave, na.rm  = T),
mol.C.Fraction.med = median(molFractionC, na.rm = T),
mol.C.Fraction.min = min(molFractionC, na.rm = T),
mol.C.Fraction.max = max(molFractionC, na.rm = T)) %>%
arrange(desc(Compound.Name))
write.csv(Wei.quanDatSum, "data_processed/Quantified_Summary.csv")
write.csv(Wei.quanDat4, "data_processed/Quantified_Full.csv")
write.csv(Wei.TotalMoles, "data_processed/Quantified_per_SampID.csv")
